<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>2 Agent - Elixir</title>
  <link href="http://feeds.feedburner.com/ElixirLang" rel="alternate" title="Elixir's Blog" type="application/atom+xml" />
  <link rel="stylesheet" type="text/css" href="/css/style.css">
  <link rel="stylesheet" type="text/css" href="/css/syntax.css">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" id="font-bitter-css" href="http://fonts.googleapis.com/css?family=Bitter&amp;ver=1" type="text/css" media="screen">
</head>

<body class="getting_started">
  <div id="container">
    <div class="wrap">
    <div id="header">
      <div id="branding">
        <h1 id="site-title">
          <a href="/" title="Elixir" rel="Home">
            <img class="logo" src="/images/logo/logo.png" alt="Elixir Logo" />
          </a>
        </h1>
      </div>

      <div id="menu-primary" class="menu-container">
        <div class="menu">
          <ul id="menu-primary-items">
            <li class="menu-item home"><a class="spec" href="/">Home</a></li>
            <li class="menu-item install"><a class="spec" href="/install.html">Install</a></li>
            <li class="menu-item getting_started"><a class="spec" href="/getting_started/1.html">Getting Started</a></li>
            <li class="menu-item docs"><a class="spec" href="/docs.html">Docs</a></li>
            <li class="menu-item blog"><a class="spec" href="/blog">Blog</a></li>
            <li class="menu-item source"><a class="spec" href="https://github.com/elixir-lang/elixir">Source</a></li>
            <li class="menu-item packages"><a class="spec" href="http://hex.pm/">Packages</a></li>

          </ul>
        </div>
      </div>

      <div class="clear"></div>
    </div>

    <div id="main">


<div id="sidebar-primary" class="sidebar">
  <div class="widget news">
  <h3>
    News: <a href="/blog/2014/09/18/elixir-v1-0-0-released/">Elixir v1.0.0 released</a>
  </h3>
</div>

<div class="widget search">
  <form method="get" class="search-form" action="http://www.google.com/search">
		<div>
			<input class="search-text" type="text" name="q" placeholder="Search..." id="searchfield">
			<input type="hidden" name="sitesearch" value="elixir-lang.org">
			<input class="search-submit button" name="submit" type="submit" value="Search">
		</div>
	</form>
</div>

  <div class="widget">
    <h3 class="widget-title">Getting Started</h3>
    <ol>
      <li><a class="spec" href="/getting_started/1.html">Interactive Elixir (IEx)</a></li>
      <li><a class="spec" href="/getting_started/2.html">Basic types</a></li>
      <li><a class="spec" href="/getting_started/3.html">Basic operators</a></li>
      <li><a class="spec" href="/getting_started/4.html">Pattern matching</a></li>
      <li><a class="spec" href="/getting_started/5.html">case, cond and if</a></li>
      <li><a class="spec" href="/getting_started/6.html">Binaries, strings and char lists</a></li>
      <li><a class="spec" href="/getting_started/7.html">Keywords, maps and dicts</a></li>
      <li><a class="spec" href="/getting_started/8.html">Modules</a></li>
      <li><a class="spec" href="/getting_started/9.html">Recursion</a></li>
      <li><a class="spec" href="/getting_started/10.html">Enumerables and streams</a></li>
      <li><a class="spec" href="/getting_started/11.html">Processes</a></li>
      <li><a class="spec" href="/getting_started/12.html">IO</a></li>
      <li><a class="spec" href="/getting_started/13.html">alias, require and import</a></li>
      <li><a class="spec" href="/getting_started/14.html">Module attributes</a></li>
      <li><a class="spec" href="/getting_started/15.html">Structs</a></li>
      <li><a class="spec" href="/getting_started/16.html">Protocols</a></li>
      <li><a class="spec" href="/getting_started/17.html">try, catch and rescue</a></li>
      <li><a class="spec" href="/getting_started/18.html">Comprehensions</a></li>
      <li><a class="spec" href="/getting_started/19.html">Sigils</a></li>
      <li><a class="spec" href="/getting_started/20.html">Where to go next</a></li>
    </ol>
  </div>
  <div class="widget">
    <h3 class="widget-title">Mix and OTP</h3>
    <ol>
      <li><a class="spec" href="/getting_started/mix_otp/1.html">Introduction to Mix</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/2.html">Agent</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/3.html">GenServer</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/4.html">GenEvent</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/5.html">Supervisor and Application</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/6.html">ETS</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/7.html">Dependencies and umbrella apps</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/8.html">Task and gen_tcp</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/9.html">Docs, tests and pipelines</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/10.html">Distributed tasks and configuration</a></li>
    </ol>
  </div>
  <div class="widget">
    <h3 class="widget-title">Meta-programming in Elixir</h3>
    <ol>
      <li><a class="spec" href="/getting_started/meta/1.html">Quote and unquote</a></li>
      <li><a class="spec" href="/getting_started/meta/2.html">Macros</a></li>
      <li><a class="spec" href="/getting_started/meta/3.html">Domain Specific Languages</a></li>
    </ol>
  </div>

  <div class="widget">
  <h3 class="widget-title">Learning resources</h3>
  <ul>
    <li class="image"><a href="http://pragprog.com/titles/elixir" title="Programming Elixir cover"><img src="http://imagery.pragprog.com/products/361/elixir_xlargebeta.jpg?1368724397" /></a></li>
    <li class="image"><a href="http://elixirsips.com" title="ElixirSips cover"><img src="http://elixirsips.com/images/ElixirLangAd2_190x160.png" width="190" height="160" /></a></li>
    <li class="image"><a href="http://manning.com/juric/" title="Elixir in Action"><img src="http://manning.com/juric/juric_cover150.jpg" width="190" height="238" /></a></li>
    <li class="image"><a href="http://www.exotpbook.com/" title="The Little Elixir and OTP Guidebook"><img src="http://i.imgur.com/G6icQmt.png" width="190" height="274" /></a></li>
    <li class="image"><a href="http://shop.oreilly.com/product/0636920030584.do" title="Introducing Elixir"><img src="http://akamaicovers.oreilly.com/images/0636920030584/rc_cat.gif" width="190" /></a></li>
  </ul>
</div>

  <div class="widget">
  <h3 class="widget-title">Code editor support</h3>
  <ul>
    <li><a class="spec" href="https://github.com/elixir-lang/emacs-elixir">Emacs Mode</a></li>
    <li><a class="spec" href="https://github.com/elixir-lang/elixir-tmbundle">Textmate Bundle</a></li>
    <li><a class="spec" href="https://github.com/elixir-lang/vim-elixir">Vim Elixir</a></li>
    <li><a class="spec" href="https://github.com/SteffenBauer/elixir-gtksourceview">GtkSourceView (gedit)</a></li>
    <li><a class="spec" href="https://github.com/lucasmazza/language-elixir">Atom Package</a></li>
  </ul>
</div>

  <div class="widget">
  <h3 class="widget-title">Sponsors</h3>
  <ul>
    <li class="image"><a href="http://plataformatec.com.br" title="Plataformatec"><img class="no-border" src="/images/logo/plataformatec.png" /></a></li>
  </ul>
</div>
</div>

<div id="content">
  <article>
    <h1 id="2-agent">2 Agent</h1>

<p><div class="toc"></div></p>

<p>この章では<code>KV.Bucket</code>というモジュールを作ります。このモジュールはキーバリューの読込や変更に対して異なるプロセスで反応します。</p>

<p>In this chapter, we will create a module named <code>KV.Bucket</code>. This module will be responsible for storing our key-value entries in a way that allows reading and modification by different processes.</p>

<p>もしGetting Startedのガイドを読み飛ばしていたり、前に読んでから時間が経ってしまった場合、<a href="/getting_started/11.html">Processes</a>の章を読み直すことをお勧めします。この章ではProcessesの知識が前提です。</p>

<p>If you have skipped the Getting Started guide or if you have read it long ago, be sure to re-read the chapter about <a href="/getting_started/11.html">プロセス</a>. We will use it as starting point.</p>

<h2 id="2-1-ステートの問題点-the-trouble-with-state">2.1 ステートの問題点 - The trouble with state</h2>

<p>Elixirはイミュータブルな言語で、通常では共有させることができません。もしバケットを複数の場所で作成、保存、操作などを行う場合、Elixirではふたつの方法が用意されています。</p>

<p>Elixir is an immutable language where nothing is shared by default. If we want to create buckets, store and access them from multiple places, we have two main options in Elixir:</p>

<ul>
<li>プロセス</li>
<li><p><a href="http://www.erlang.org/doc/man/ets.html">ETS (Erlang Term Storage)</a></p></li>
<li><p>Processes</p></li>
<li><p><a href="http://www.erlang.org/doc/man/ets.html">ETS (Erlang Term Storage)</a></p></li>
</ul>

<p>ここではまずETSというものがどういった違いについて触れる必要があるまでプロセスについて紹介します。プロセスの代わりにETSを用いるケースは滅多にありませんが、ElixirとOTPで抽象的な操作を行うことができます。</p>

<p>We have talked about processes, while ETS is something new that we will explore later in this guide. When it comes to processes though, we rarely hand-roll our own process, instead we use the abstractions available in Elixir and OTP:</p>

<ul>
<li><a href="/docs/stable/elixir/Agent.html">エージェント</a> - ステート周りのシンプルなラッパー</li>
<li><a href="/docs/stable/elixir/GenServer.html">GenServer</a> - プロセスをカプセル化したり、同期通信、非同期通信やコードの再読込をサポートするジェネリックなサーバー</li>
<li><a href="/docs/stable/elixir/GenEvent.html">GenEvent</a> - イベントの共有化や複数のハンドラーを管理するためのジェネリックなイベント</li>
<li><p><a href="/docs/stable/elixir/Task.html">タスク</a> - プロセスを発行したり、後から簡単に呼び出すことができる非同期処理の単位</p></li>
<li><p><a href="/docs/stable/elixir/Agent.html">Agent</a> - Simple wrappers around state</p></li>
<li><p><a href="/docs/stable/elixir/GenServer.html">GenServer</a> - &quot;Generic servers&quot; (processes) that encapsulate state, provide sync and async calls, support code reloading, and more</p></li>
<li><p><a href="/docs/stable/elixir/GenEvent.html">GenEvent</a> - &quot;Generic event&quot; managers that allow publishing events to multiple handlers</p></li>
<li><p><a href="/docs/stable/elixir/Task.html">Task</a> - Asynchronous units of computation that allow spawning a process and easily retrieving its result at a later time</p></li>
</ul>

<p>これらの抽象的な操作はすべて網羅していきます。これらがプロセスでVMの機能にある<code>send</code>、<code>receive</code>、<code>spawn</code>、<code>link</code>を包括していることを覚えていてください。</p>

<p>We will explore all of these abstractions in this guide. Keep in mind that they are all implemented on top of processes using the basic features provided by the VM, like <code>send</code>, <code>receive</code>, <code>spawn</code> and <code>link</code>.</p>

<h2 id="2-2-エージェント-agents">2.2 エージェント - Agents</h2>

<p><a href="/docs/stable/elixir/Agent.html">エージェント</a>はステートにおけるシンプルなラッパーです。もし状態を保つためにプロセスを使うのであれば、エージェントがうまく解決してくれます。それでは早速プロジェクトのディレクトリで<code>iex</code>を起動させてください。</p>

<p><a href="/docs/stable/elixir/Agent.html">Agents</a> are simple wrappers around state. If all you want from a process is to keep state, agents are a great fit. Let&#39;s start an <code>iex</code> session inside the project with:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ iex -S mix
</code></pre></div>
<p>まずはエージェントの簡単な例で説明します。</p>

<p>And play a bit with agents:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">agent</span><span class="p">}</span> <span class="p">=</span> <span class="nc">Agent</span><span class="p">.</span><span class="n">start_link</span> <span class="k">fn</span> <span class="p">-&gt;</span> <span class="p">[]</span> <span class="k">end</span>
<span class="go">{:ok, #PID&lt;0.57.0&gt;}</span>
<span class="gp">iex&gt; </span><span class="nc">Agent</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">agent</span><span class="p">,</span> <span class="k">fn</span> <span class="n">list</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="s2">&quot;eggs&quot;</span><span class="p">|</span><span class="n">list</span><span class="p">]</span> <span class="k">end</span><span class="p">)</span>
<span class="go">:ok</span>
<span class="gp">iex&gt; </span><span class="nc">Agent</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">agent</span><span class="p">,</span> <span class="k">fn</span> <span class="n">list</span> <span class="p">-&gt;</span> <span class="n">list</span> <span class="k">end</span><span class="p">)</span>
<span class="go">[&quot;eggs&quot;]</span>
<span class="gp">iex&gt; </span><span class="nc">Agent</span><span class="p">.</span><span class="n">stop</span><span class="p">(</span><span class="n">agent</span><span class="p">)</span>
<span class="go">:ok</span>
</code></pre></div>
<p>まずは空のリストを持ったステートのエージェントから始めます。次に、ステートを更新するコマンドを発して、新しいアイテムをリストの先頭に追加します。最後はリスト全体を検索します。エージェントが完了したら<code>Agent.stop/1</code>を呼んでプロセスを完全に終了させます。</p>

<p>We started an agent with an initial state of an empty list. Next, we issue a command to update the state, adding our new item to the head of the list. Finally, we retrieved the whole list. Once we are done with the agent, we can call <code>Agent.stop/1</code> to terminate the agent process.</p>

<p><code>KV.Bucket</code>はエージェントを使って用意するのですが、その前にいくつか最初のテストを用意します。<code>test/kv/bucket_test.exs</code>というファイル(<code>.exs</code>は拡張子)を用意してください。</p>

<p>Let&#39;s implement our <code>KV.Bucket</code> using agents. But before starting the implementation, let&#39;s first write some tests. Create a file at <code>test/kv/bucket_test.exs</code> (remember the <code>.exs</code> extension) with the following:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">KV.BucketTest</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="nc">ExUnit.Case</span><span class="p">,</span> <span class="ss">async</span><span class="p">:</span> <span class="no">true</span>

  <span class="n">test</span> <span class="s2">&quot;stores values by key&quot;</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Bucket</span><span class="p">.</span><span class="n">start_link</span>
    <span class="n">assert</span> <span class="nc">KV.Bucket</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="s2">&quot;milk&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="no">nil</span>

    <span class="nc">KV.Bucket</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="s2">&quot;milk&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">assert</span> <span class="nc">KV.Bucket</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="s2">&quot;milk&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>最初のテストは簡潔です。まずは<code>KV.Bucket</code>を作り、そのアサーションは単純に<code>get/2</code>と<code>put/3</code>が操作した結果を用意します。これらを止める方法は、テストそのもののプロセスはテストの終了に伴って自動で行われるためにわざわざ用意する必要がありません。</p>

<p>Our first test is straightforward. We start a new <code>KV.Bucket</code> and perform some <code>get/2</code> and <code>put/3</code> operations on it, asserting the result. We don&#39;t need to explicitly stop the agent because it is linked to the test process and the agent is shut down automatically once the test finishes.</p>

<p>もうひとつ注意すべき部分は<code>ExUnit.Case</code>の<code>async: true</code>という設定をしなければならない点です。これはこのテストが他のテストケースも含めて一斉に実行されるという<code>:async</code>オプションです。これはCPUのコアの数だけテストケース全体を高速化させることができるので非常に便利です。ただし<code>:async</code>オプションを有効にしている間はグローバルな値を参照させたり、変更させることはできません。例えば、テストにファイルシステムを用いたり、プロセスを登録したり、データベースの操作などを行う場合はテストを行っている間は非同期させないようにしてください。</p>

<p>Also note that we passed the <code>async: true</code> option to <code>ExUnit.Case</code>. This option makes this test case run in parallel with other test cases that set up the <code>:async</code> option. This is extremely useful to speed up our test suite by using multiple cores in our machine. Note though the <code>:async</code> option must only be set if the test case does not rely or change any global value. For example, if the test requires writing to the filesystem, registering processes, accessing a database, you must not make it async to avoid race conditions in between tests.</p>

<p>非同期が必要か不要かどうかに拘らず、先ほど用意したばかりのテストは当然何も関数的な記述がなされていないために必ず失敗します。</p>

<p>Regardless of being async or not, our new test should obviously fail, as none of the functionality is implemented.</p>

<p>テストの失敗を修正するために、<code>lib/kv/bucket.ex</code>というファイルを用意します。次のような例を写す前に自分で<code>KV.Bucket</code>を用意しても構いません。</p>

<p>In order to fix the failing test, let&#39;s create a file at <code>lib/kv/bucket.ex</code> with the contents below. Feel free to give a try at implementing the <code>KV.Bucket</code> module yourself using agents before peeking the implementation below.</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">KV.Bucket</span> <span class="k">do</span>
  <span class="na">@doc</span> <span class="sh">&quot;&quot;&quot;</span>
<span class="sh">  新しいバケットを開始する。</span>
<span class="sh">  &quot;&quot;&quot;</span>
  <span class="kd">def</span> <span class="n">start_link</span> <span class="k">do</span>
    <span class="nc">Agent</span><span class="p">.</span><span class="n">start_link</span><span class="p">(</span><span class="k">fn</span> <span class="p">-&gt;</span> <span class="nc">HashDict</span><span class="p">.</span><span class="n">new</span> <span class="k">end</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="na">@doc</span> <span class="sh">&quot;&quot;&quot;</span>
<span class="sh">  バケットから値を取得する。</span>
<span class="sh">  &quot;&quot;&quot;</span>
  <span class="kd">def</span> <span class="n">get</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">do</span>
    <span class="nc">Agent</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="o">&amp;</span><span class="nc">HashDict</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="ni">&amp;1</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
  <span class="k">end</span>

  <span class="na">@doc</span> <span class="sh">&quot;&quot;&quot;</span>
<span class="sh">  バケットから渡された値を表示する。</span>
<span class="sh">  &quot;&quot;&quot;</span>
  <span class="kd">def</span> <span class="n">put</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">do</span>
    <span class="nc">Agent</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="o">&amp;</span><span class="nc">HashDict</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="ni">&amp;1</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">KV.Bucket</span> <span class="k">do</span>
  <span class="na">@doc</span> <span class="sh">&quot;&quot;&quot;</span>
<span class="sh">  Starts a new bucket.</span>
<span class="sh">  &quot;&quot;&quot;</span>
  <span class="kd">def</span> <span class="n">start_link</span> <span class="k">do</span>
    <span class="nc">Agent</span><span class="p">.</span><span class="n">start_link</span><span class="p">(</span><span class="k">fn</span> <span class="p">-&gt;</span> <span class="nc">HashDict</span><span class="p">.</span><span class="n">new</span> <span class="k">end</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="na">@doc</span> <span class="sh">&quot;&quot;&quot;</span>
<span class="sh">  Gets a value from the `bucket` by `key`.</span>
<span class="sh">  &quot;&quot;&quot;</span>
  <span class="kd">def</span> <span class="n">get</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">do</span>
    <span class="nc">Agent</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="o">&amp;</span><span class="nc">HashDict</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="ni">&amp;1</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
  <span class="k">end</span>

  <span class="na">@doc</span> <span class="sh">&quot;&quot;&quot;</span>
<span class="sh">  Puts the `value` for the given `key` in the `bucket`.</span>
<span class="sh">  &quot;&quot;&quot;</span>
  <span class="kd">def</span> <span class="n">put</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">do</span>
    <span class="nc">Agent</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="o">&amp;</span><span class="nc">HashDict</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="ni">&amp;1</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p><code>KV.Bucket</code>モジュールが定義できればテストは成功します。この例では<code>Map</code>の代わりにHashDictを使って状態を保存しています。現在のバージョンのElixirではマップに巨大なキーを持たせることが非効率だからです。</p>

<p>With the <code>KV.Bucket</code> module defined, our test should pass! Note that we are using a HashDict to store our state instead of a <code>Map</code>, because in the current version of Elixir maps are less efficient when holding a large number of keys.</p>

<h2 id="2-3-exunitのコールバック-exunit-callbacks">2.3 ExUnitのコールバック - ExUnit callbacks</h2>

<p><code>KV.Bucket</code>の追加機能をもう少し掘り下げて、ExUnitのコールバックについて触れていきます。<code>KV.Bucket</code>のテストを毎回セットアップと終了後の処理に関する振る舞いもテストに含めなければならないと思われるかもしれませんが、ExUnitには反復的なタスクを省略させるためのコールバックが備わっています。</p>

<p>Before moving on and adding more features to <code>KV.Bucket</code>, let&#39;s talk about ExUnit callbacks. As you may expect, all <code>KV.Bucket</code> tests will require a bucket to be started during setup and stopped after the test. Luckily, ExUnit supports callbacks that allow us to skip such repetitive tasks.</p>

<p>テストケースをコールバックを用いて書き直してみましょう。</p>

<p>Let&#39;s rewrite the test case to use callbacks:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">KV.BucketTest</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="nc">ExUnit.Case</span><span class="p">,</span> <span class="ss">async</span><span class="p">:</span> <span class="no">true</span>

  <span class="n">setup</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Bucket</span><span class="p">.</span><span class="n">start_link</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="ss">bucket</span><span class="p">:</span> <span class="n">bucket</span><span class="p">}</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="s2">&quot;stores values by key&quot;</span><span class="p">,</span> <span class="p">%{</span><span class="ss">bucket</span><span class="p">:</span> <span class="n">bucket</span><span class="p">}</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="nc">KV.Bucket</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="s2">&quot;milk&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="no">nil</span>

    <span class="nc">KV.Bucket</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="s2">&quot;milk&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">assert</span> <span class="nc">KV.Bucket</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="s2">&quot;milk&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>まず最初にセットアップに用いる<code>setup/1</code>というコールバックを定義しました。<code>setup/1</code>はすべてのテストが始まる前に実行され、テストに毎回必要な処理を定義しておくことができます。</p>

<p>We have first defined a setup callback with the help of the <code>setup/1</code> macro. The <code>setup/1</code> callback runs before every test, in the same process as the test itself.</p>

<p>バケットをテストするにはpidを扱う必要があり、<em>テストコンテクスト</em>と呼ばれる方法を使います。これは<code>{:ok, bucket: bucket}</code>がコールバックによって返されると、ExUnitはふたつめの要素のタプル(あるいは辞書)をテストコンテクストにまとめます。テストコンテクストはテストの定義やブロックの値を参照するための手段です。</p>

<p>Note that we need a mechanism to pass the <code>bucket</code> pid from the callback to the test. We do so by using the <em>test context</em>. When we return <code>{:ok, bucket: bucket}</code> from the callback, ExUnit will merge the second element of the tuple (a dictionary) into the test context. The test context is a map which we can then match in the test definition, providing access to these values inside the block:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">test</span> <span class="s2">&quot;stores values by key&quot;</span><span class="p">,</span> <span class="p">%{</span><span class="ss">bucket</span><span class="p">:</span> <span class="n">bucket</span><span class="p">}</span> <span class="k">do</span>
  <span class="c1"># バケットはセットアップのブロックから引き継がれます。</span>
<span class="k">end</span>
</code></pre></div><div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">test</span> <span class="s2">&quot;stores values by key&quot;</span><span class="p">,</span> <span class="p">%{</span><span class="ss">bucket</span><span class="p">:</span> <span class="n">bucket</span><span class="p">}</span> <span class="k">do</span>
  <span class="c1"># `bucket` is now the bucket from the setup block</span>
<span class="k">end</span>
</code></pre></div>
<p>ExUnitのケースについては<a href="/docs/stable/ex_unit/ExUnit.Case.html"><code>ExUnit.Case</code>モジュールの ドキュメント</a>と<a href="/docs/stable/ex_unit/ExUnit.Callbacks.html"><code>ExUnit.Callbacks</code> のドキュメント</a>を参照してください。</p>

<p>You can read more about ExUnit cases in the <a href="/docs/stable/ex_unit/ExUnit.Case.html"><code>ExUnit.Case</code> module documentation</a> and more about callbacks in <a href="/docs/stable/ex_unit/ExUnit.Callbacks.html"><code>ExUnit.Callbacks</code> docs</a>.</p>

<h2 id="2-4-その他のエージェント操作-other-agent-actions">2.4 その他のエージェント操作 - Other Agent actions</h2>

<p>バケットの値を取得と更新を行う<code>Agent.get_and_update/2</code>という関数と、キーからバケットの消去を行う<code>KV.Bucket.delete/2</code>という関数をそれぞれ実装してみましょう。</p>

<p>Besides getting a value and updating the agent state, agents allow us to get a value and update the agent state in one function call via <code>Agent.get_and_update/2</code>. Let&#39;s implement a <code>KV.Bucket.delete/2</code> function that deletes a key from the bucket, returning its current value:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="na">@doc</span> <span class="sh">&quot;&quot;&quot;</span>
<span class="sh">キーとバケットの消去。</span>

<span class="sh">キーが存在すれば、そのキーの値を返す</span>
<span class="sh">&quot;&quot;&quot;</span>
<span class="kd">def</span> <span class="n">delete</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">do</span>
  <span class="nc">Agent</span><span class="p">.</span><span class="n">get_and_update</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="o">&amp;</span><span class="nc">HashDict</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="ni">&amp;1</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
<span class="k">end</span>
</code></pre></div><div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="na">@doc</span> <span class="sh">&quot;&quot;&quot;</span>
<span class="sh">Deletes `key` from `bucket`.</span>

<span class="sh">Returns the current value of `key`, if `key` exists.</span>
<span class="sh">&quot;&quot;&quot;</span>
<span class="kd">def</span> <span class="n">delete</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">do</span>
  <span class="nc">Agent</span><span class="p">.</span><span class="n">get_and_update</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="o">&amp;</span><span class="nc">HashDict</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="ni">&amp;1</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
<span class="k">end</span>
</code></pre></div>
<p>それではこの関数を満たすテストケースを書いてみましょう。もちろん、エージェントに関する詳しいドキュメントを読んでみてもよいでしょう。</p>

<p>Now it is your turn to write a test for the functionality above! Also, be sure to explore the documentation for Agents to learn more about them.</p>

<h2 id="2-5-クライアントとサーバーのエージェント-client-server-in-agents">2.5 クライアントとサーバーのエージェント - Client/Server in Agents</h2>

<p>次の章へ移る前に、クライアントとサーバーの二分法について触れておきましょう。先ほどの<code>delete/2</code>を拡張します。</p>

<p>Before we move on to the next chapter, let&#39;s discuss the client/server dichotomy in agents. Let&#39;s expand the <code>delete/2</code> function we have just implemented:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">def</span> <span class="n">delete</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">do</span>
  <span class="nc">Agent</span><span class="p">.</span><span class="n">get_and_update</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="k">fn</span> <span class="n">dict</span><span class="p">-&gt;</span>
    <span class="nc">HashDict</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
  <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>関数に含まれているものすべてがエージェントのプロセスで実行されます。今回はエージェントのプロセスがクライアントのリクエストを処理します。エージェントのプロセスをサーバーとして、サーバーの外側で発せられるものすべてをクライアントとして説明します。</p>

<p>Everything that is inside the function we passed to the agent happens in the agent process. In this case, since the agent process is the one receiving and responding to our messages, we say the agent process is the server. Everything outside the function is happening in the client.</p>

<p>この区別は重要です。もし、一度の処理に必要な手続きが多いときはサーバーとクライアントのどちらで処理をさせれば負荷を軽減させるか考えなければなりません。例えば、</p>

<p>This distinction is important. If there are expensive actions to be done, you must consider if it will be better to perform these actions on the client or on the server. For example:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">def</span> <span class="n">delete</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">do</span>
  <span class="ss">:timer</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="c1"># クライアントを待機させる</span>
  <span class="nc">Agent</span><span class="p">.</span><span class="n">get_and_update</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="k">fn</span> <span class="n">dict</span> <span class="p">-&gt;</span>
    <span class="ss">:timer</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="c1"># サーバーを待機させる</span>
    <span class="nc">HashDict</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
  <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">def</span> <span class="n">delete</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">do</span>
  <span class="ss">:timer</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="c1"># sleeps the client</span>
  <span class="nc">Agent</span><span class="p">.</span><span class="n">get_and_update</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="k">fn</span> <span class="n">dict</span> <span class="p">-&gt;</span>
    <span class="ss">:timer</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="c1"># sleeps the server</span>
    <span class="nc">HashDict</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
  <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>サーバー側に膨大な処理をさせている場合、すべてのアクションが完了するまでサーバーはずっと待機状態にさせなければならず、その結果クライアントに対してタイムアウトが発生させてしまうかもしれません。</p>

<p>When a long action is performed on the server, all other requests to that particular server will wait until the action is done, which may cause some clients to timeout.</p>

<p>次の章ではGenServersについて、クライアントとサーバーのはっきりとした違いについて説明していきます。</p>

<p>In the next chapter we will explore GenServers, where the segregation between clients and servers is made even more apparent.</p>

  </article><!-- .hfeed -->

  
  <div class="pagination loop-pagination">
    
      <a href="1.html" class="previous page-numbers spec">&larr; Previous</a>
    
      <a class="page-numbers spec" href="#container">Top</a>
    
      <a href="3.html" class="next page-numbers spec">Next &rarr;</a>
    
  </div>
  
</div><!-- #content -->

      </div><!-- #main -->

      <div class="clear">
      </div>

      <div id="copyright">
        © 2012-2014 <a href="http://plataformatec.com.br/">Plataformatec</a>. All rights reserved.
      </p>
    </div><!-- .wrap -->
  </div><!-- #container -->

  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-8268430-6']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script src="/js/toc/toc.js" type="text/javascript" charset="utf-8"></script>
  <script type="text/javascript">
    $(document).ready(function() {
        $('.toc').toc({
          title: '',
          listType: 'ul',
          showSpeed: 0,
        });
    });
  </script>
</body>
</html>


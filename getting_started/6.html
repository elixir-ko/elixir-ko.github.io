<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>6 바이너리, 문자열, 문자 리스트 - Binaries, strings and char lists - Elixir</title>
  <link href="http://feeds.feedburner.com/ElixirLang" rel="alternate" title="Elixir's Blog" type="application/atom+xml" />
  <link rel="stylesheet" type="text/css" href="/css/style.css">
  <link rel="stylesheet" type="text/css" href="/css/syntax.css">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" id="font-bitter-css" href="http://fonts.googleapis.com/css?family=Bitter&amp;ver=1" type="text/css" media="screen">
</head>

<body class="getting_started">
  <div id="container">
    <div class="wrap">
    <div id="header">
      <div id="branding">
        <h1 id="site-title">
          <a href="/" title="Elixir" rel="Home">
            <img class="logo" src="/images/logo/logo.png" alt="Elixir Logo" />
          </a>
        </h1>
      </div>

      <div id="menu-primary" class="menu-container">
        <div class="menu">
          <ul id="menu-primary-items">
            <li class="menu-item home"><a class="spec" href="/">Home</a></li>
            <li class="menu-item install"><a class="spec" href="/install.html">Install</a></li>
            <li class="menu-item getting_started"><a class="spec" href="/getting_started/1.html">Getting Started</a></li>
            <li class="menu-item docs"><a class="spec" href="/docs.html">Docs</a></li>
            <li class="menu-item blog"><a class="spec" href="/blog">Blog</a></li>
            <li class="menu-item source"><a class="spec" href="https://github.com/elixir-lang/elixir">Source</a></li>
            <li class="menu-item packages"><a class="spec" href="http://hex.pm/">Packages</a></li>

          </ul>
        </div>
      </div>

      <div class="clear"></div>
    </div>

    <div id="main">


         
<div id="sidebar-primary" class="sidebar">
  <div class="widget news">
  <h3>
    News: <a href="/blog/2014/09/18/elixir-v1-0-0-released/">Elixir v1.0.0 released</a>
  </h3>
</div>

<div class="widget search">
  <form method="get" class="search-form" action="http://www.google.com/search">
		<div>
			<input class="search-text" type="text" name="q" placeholder="Search..." id="searchfield">
			<input type="hidden" name="sitesearch" value="elixir-lang.org">
			<input class="search-submit button" name="submit" type="submit" value="Search">
		</div>
	</form>
</div>

  <div class="widget">
    <h3 class="widget-title">Getting Started</h3>
    <ol>
      <li><a class="spec" href="/getting_started/1.html">Interactive Elixir (IEx)</a></li>
      <li><a class="spec" href="/getting_started/2.html">Basic types</a></li>
      <li><a class="spec" href="/getting_started/3.html">Basic operators</a></li>
      <li><a class="spec" href="/getting_started/4.html">Pattern matching</a></li>
      <li><a class="spec" href="/getting_started/5.html">case, cond and if</a></li>
      <li><a class="spec" href="/getting_started/6.html">Binaries, strings and char lists</a></li>
      <li><a class="spec" href="/getting_started/7.html">Keywords, maps and dicts</a></li>
      <li><a class="spec" href="/getting_started/8.html">Modules</a></li>
      <li><a class="spec" href="/getting_started/9.html">Recursion</a></li>
      <li><a class="spec" href="/getting_started/10.html">Enumerables and streams</a></li>
      <li><a class="spec" href="/getting_started/11.html">Processes</a></li>
      <li><a class="spec" href="/getting_started/12.html">IO</a></li>
      <li><a class="spec" href="/getting_started/13.html">alias, require and import</a></li>
      <li><a class="spec" href="/getting_started/14.html">Module attributes</a></li>
      <li><a class="spec" href="/getting_started/15.html">Structs</a></li>
      <li><a class="spec" href="/getting_started/16.html">Protocols</a></li>
      <li><a class="spec" href="/getting_started/17.html">try, catch and rescue</a></li>
      <li><a class="spec" href="/getting_started/18.html">Comprehensions</a></li>
      <li><a class="spec" href="/getting_started/19.html">Sigils</a></li>
      <li><a class="spec" href="/getting_started/20.html">Where to go next</a></li>
    </ol>
  </div>
  <div class="widget">
    <h3 class="widget-title">Mix and OTP</h3>
    <ol>
      <li><a class="spec" href="/getting_started/mix_otp/1.html">Introduction to Mix</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/2.html">Agent</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/3.html">GenServer</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/4.html">GenEvent</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/5.html">Supervisor and Application</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/6.html">ETS</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/7.html">Dependencies and umbrella apps</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/8.html">Task and gen_tcp</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/9.html">Docs, tests and pipelines</a></li>
      <li><a class="spec" href="/getting_started/mix_otp/10.html">Distributed tasks and configuration</a></li>
    </ol>
  </div>
  <div class="widget">
    <h3 class="widget-title">Meta-programming in Elixir</h3>
    <ol>
      <li><a class="spec" href="/getting_started/meta/1.html">Quote and unquote</a></li>
      <li><a class="spec" href="/getting_started/meta/2.html">Macros</a></li>
      <li><a class="spec" href="/getting_started/meta/3.html">Domain Specific Languages</a></li>
    </ol>
  </div>

  <div class="widget">
  <h3 class="widget-title">Learning resources</h3>
  <ul>
    <li class="image"><a href="http://pragprog.com/titles/elixir" title="Programming Elixir cover"><img src="http://imagery.pragprog.com/products/361/elixir_xlargebeta.jpg?1368724397" /></a></li>
    <li class="image"><a href="http://elixirsips.com" title="ElixirSips cover"><img src="http://elixirsips.com/images/ElixirLangAd2_190x160.png" width="190" height="160" /></a></li>
    <li class="image"><a href="http://manning.com/juric/" title="Elixir in Action"><img src="http://manning.com/juric/juric_cover150.jpg" width="190" height="238" /></a></li>
    <li class="image"><a href="http://www.exotpbook.com/" title="The Little Elixir and OTP Guidebook"><img src="http://i.imgur.com/G6icQmt.png" width="190" height="274" /></a></li>
    <li class="image"><a href="http://shop.oreilly.com/product/0636920030584.do" title="Introducing Elixir"><img src="http://akamaicovers.oreilly.com/images/0636920030584/rc_cat.gif" width="190" /></a></li>
  </ul>
</div>

  <div class="widget">
  <h3 class="widget-title">Code editor support</h3>
  <ul>
    <li><a class="spec" href="https://github.com/elixir-lang/emacs-elixir">Emacs Mode</a></li>
    <li><a class="spec" href="https://github.com/elixir-lang/elixir-tmbundle">Textmate Bundle</a></li>
    <li><a class="spec" href="https://github.com/elixir-lang/vim-elixir">Vim Elixir</a></li>
    <li><a class="spec" href="https://github.com/SteffenBauer/elixir-gtksourceview">GtkSourceView (gedit)</a></li>
    <li><a class="spec" href="https://github.com/lucasmazza/language-elixir">Atom Package</a></li>
  </ul>
</div>

  <div class="widget">
  <h3 class="widget-title">Sponsors</h3>
  <ul>
    <li class="image"><a href="http://plataformatec.com.br" title="Plataformatec"><img class="no-border" src="/images/logo/plataformatec.png" /></a></li>
  </ul>
</div>
</div>

<div id="content">
  <article>
    <h1 id="6-바이너리-문자열-문자-리스트-binaries-strings-and-char-lists">6 바이너리, 문자열, 문자 리스트 - Binaries, strings and char lists</h1>

<p><div class="toc"></div></p>

<p>&quot;기본 타입&quot;에서 문자열에 대해 배웠고 타입체크를 위해 <code>is_binary/1</code> 을 사용했습니다:</p>

<p>In &quot;Basic types&quot;, we learned about strings and used the <code>is_binary/1</code> function for checks:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="n">string</span> <span class="p">=</span> <span class="s2">&quot;hello&quot;</span>
<span class="go">&quot;hello&quot;</span>
<span class="gp">iex&gt; </span><span class="n">is_binary</span> <span class="n">string</span>
<span class="go">true</span>
</code></pre></div>
<p>이 장에서는 바이너리가 무엇인지, 문자열과는 어떤 관계인지, <code>&#39;이렇게&#39;</code> 작은따옴표로 묶인 값은 Elixir 에서 어떤 의미를 가지는지에 대해 살펴볼 것입니다.</p>

<p>In this chapter, we will understand what binaries are, how they associate with strings, and what a single-quoted value, <code>&#39;like this&#39;</code>, means in Elixir.</p>

<h2 id="6-1-utf-8-와-unicode-utf-8-and-unicode">6.1 UTF-8 와 Unicode - UTF-8 and Unicode</h2>

<p>문자열은 UTF-8로 인코딩 된 바이너리입니다. 그것이 실제로 무슨 뜻인지 이해하기 위해서 바이트 및 코드 포인트의 차이를 모르면 안됩니다.</p>

<p>A string is a UTF-8 encoded binary. In order to understand exactly what we mean by that, we need to understand the difference between bytes and code points.</p>

<p>유니 코드 표준은 우리가 알고있는 많은 문자에 코드 포인트를 할당해 두었습니다. 예를들어 문자 <code>a</code> 는 <code>97</code> 이라는 코드 포인트를 가지고 있고, 캐릭터 <code>ł</code> 는 <code>322</code> 코드 포인트를 가지고 있습니다. 디스크에 문자열 <code>&quot;hełło&quot;</code>를 쓸 때 코드 포인트를 바이트로 변환해야 합니다. 만약 하나의 코드 포인트를 1 바이트로 표현한다면 <code>&quot;hełło&quot;</code> 라고 쓸 수 없습니다. 왜냐하면 <code>ł</code> 코드 포인트는 <code>322</code> 이며, 1 바이트는 <code>0</code> 에서 <code>255</code> 까지 밖에 표현할 수 없기 때문입니다. 그러나 화면에서는 <code>&quot;hełło&quot;</code> 를 읽을 수 있지요. 그것은 <em>신비의 기술</em> 로 표현되어 있기 때문입니다. 바로 인코딩되어 있기 때문입니다.</p>

<p>The Unicode standard assigns code points to many of the characters we know. For example, the letter <code>a</code> has code point <code>97</code> while the letter <code>ł</code> has code point <code>322</code>. When writing the string <code>&quot;hełło&quot;</code> to disk, we need to convert this code point to bytes. If we adopted a rule that said one byte represents one code point, we wouldn&#39;t be able to write <code>&quot;hełło&quot;</code>, because it uses the code point <code>322</code> for <code>ł</code>, and one byte can only represent a number from <code>0</code> to <code>255</code>. But of course, given you can actually read <code>&quot;hełło&quot;</code> on your screen, it must be represented <em>somehow</em>. That&#39;s where encodings come in.</p>

<p>바이트에서 코드 포인트를 표현하는 경우 어떻게 해서든 인코딩을 해야 합니다. Elixir는 기본 인코딩으로 UTF-8 인코딩을 선택했습니다. 문자열은 UTF-8로 인코딩 된 바이너리라고 말할 때 의미하는 바는 문자열은 코드 포인트를 규칙에 따라 표현한 바이트의 모임이며, 그 규칙은 UTF-8 로 인코딩 된다는 것입니다.</p>

<p>When representing code points in bytes, we need to encode them somehow. Elixir chose the UTF-8 encoding as its main and default encoding. When we say a string is a UTF-8 encoded binary, we mean a string is a bunch of bytes organized in a way to represent certain code points, as specified by the UTF-8 encoding.</p>

<p>코드 포인트가 <code>322</code> 에 할당 되어있는 <code>ł</code> 경우 표현하려면 1 바이트보다 많은 바이트가 필요합니다. 때문에 문자열을 <code>byte_size/1</code> 로 계산했을 때와 <code>String.length/1</code> 로 계산했을 때의 차이가 있습니다:</p>

<p>Since we have code points like <code>ł</code> assigned to the number <code>322</code>, we actually need more than one byte to represent it. That&#39;s why we see a difference when we calculate the <code>byte_size/1</code> of a string compared to its <code>String.length/1</code>:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="n">string</span> <span class="p">=</span> <span class="s2">&quot;hełło&quot;</span>
<span class="go">&quot;hełło&quot;</span>
<span class="gp">iex&gt; </span><span class="n">byte_size</span> <span class="n">string</span>
<span class="go">7</span>
<span class="gp">iex&gt; </span><span class="nc">String</span><span class="p">.</span><span class="n">length</span> <span class="n">string</span>
<span class="go">5</span>
</code></pre></div>
<p>UTF-8은 <code>h</code> , <code>e</code> 와 <code>o</code> 를 표현하려면 1 바이트만 들지만 <code>ł</code> 을 표현하기 위해 2 바이트 필요합니다. Elixir는 <code>?</code> 을 사용하면 코드 포인트 값을 얻을 수 있습니다:</p>

<p>UTF-8 requires one byte to represent the code points <code>h</code>, <code>e</code> and <code>o</code>, but two bytes to represent <code>ł</code>. In Elixir, you can get a code point&#39;s value by using <code>?</code>:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="sc">?a</span>
<span class="go">97</span>
<span class="gp">iex&gt; </span><span class="sc">?ł</span>
<span class="go">322</span>
</code></pre></div>
<p><a href="/docs/stable/elixir/String.html"><code>String</code> 모듈</a>의 함수를 사용하면 코드 포인트마다 문자를 나눌 수 있습니다:</p>

<p>You can also use the functions in <a href="/docs/stable/elixir/String.html">the <code>String</code> module</a> to split a string in its code points:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="nc">String</span><span class="p">.</span><span class="n">codepoints</span><span class="p">(</span><span class="s2">&quot;hełło&quot;</span><span class="p">)</span>
<span class="go">[&quot;h&quot;, &quot;e&quot;, &quot;ł&quot;, &quot;ł&quot;, &quot;o&quot;]</span>
</code></pre></div>
<p>앞으로 문자열을 다루기 위해 Elixir가 훌륭한 지원을 한다는 것을 알게될 것입니다. 유니 코드 문자 작업도 많이 지원합니다. 실제로 Elixir는 <a href="http://mortoray.com/2013/11/27/the-string-type-is-broken/">&quot;The string type is broken&quot;</a> 기사에 언급된 모든 테스트를 통과합니다.</p>

<p>You will see that Elixir has excellent support for working with strings. It also supports many of the Unicode operations. In fact, Elixir passes all the tests showcased in the article <a href="http://mortoray.com/2013/11/27/the-string-type-is-broken/">&quot;The string type is broken&quot;</a>.</p>

<p>여하튼 문자열은 스토리의 일부에 지나지 않습니다. 문자열은 바이너리이며, 우리는 (문자열) 함수 <code>is_binary/1</code> 을 사용했습니다, Elixir는 문자열에 힘을 실어 주는 근본적인 타입을 가지고 있습니다. 자 이제 바이너리 대해 살펴봅시다!</p>

<p>However, strings are just part of the story. If a string is a binary, and we have used the <code>is_binary/1</code> function, Elixir must have an underlying type empowering strings. And it does. Let&#39;s talk about binaries!</p>

<h2 id="6-2-바이너리-와-비트문자열-binaries-and-bitstrings">6.2 바이너리(와 비트문자열) - Binaries (and bitstrings)</h2>

<p>Elxir 에서 <code>&lt;&lt;&gt;&gt;</code>로 바이너리를 정의할 수 있습니다:</p>

<p>In Elixir, you can define a binary using <code>&lt;&lt;&gt;&gt;</code>:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="p">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">&gt;&gt;</span>
<span class="go">&lt;&lt;0, 1, 2, 3&gt;&gt;</span>
<span class="gp">iex&gt; </span><span class="n">byte_size</span> <span class="p">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">&gt;&gt;</span>
<span class="go">4</span>
</code></pre></div>
<p>바이너리는 단순한 바이트들의 연속입니다. 물론 이러한 바이트들은 어떤 방식으로든 구성될 수 있습니다. 말이 되지 않는 문장도 가능합니다.</p>

<p>A binary is just a sequence of bytes. Of course, those bytes can be organized in any way, even in a sequence that does not make them a valid string:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="nc">String</span><span class="p">.</span><span class="n">valid?</span><span class="p">(&lt;&lt;</span><span class="mi">239</span><span class="p">,</span> <span class="mi">191</span><span class="p">,</span> <span class="mi">191</span><span class="p">&gt;&gt;)</span>
<span class="go">false</span>
</code></pre></div>
<p>문자열 연결 작업은 사실 바이너리의 결합 입니다:</p>

<p>The string concatenation operation is actually a binary concatenation operator:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="p">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">&gt;&gt;</span> <span class="o">&lt;&gt;</span> <span class="p">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">&gt;&gt;</span>
<span class="go">&lt;&lt;0, 1, 2, 3&gt;&gt;</span>
</code></pre></div>
<p>문자열의 자체 바이너리 표현을 볼 수 있는 일반적인 방법은 null 바이트 <code>&lt;&lt;0&gt;&gt;</code>를 문자열에 결합시키는 것 입니다 :</p>

<p>A common trick in Elixir is to concatenate the null byte <code>&lt;&lt;0&gt;&gt;</code> to a string to see its inner binary representation:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="s2">&quot;hełło&quot;</span> <span class="o">&lt;&gt;</span> <span class="p">&lt;&lt;</span><span class="mi">0</span><span class="p">&gt;&gt;</span>
<span class="go">&lt;&lt;104, 101, 197, 130, 197, 130, 111, 0&gt;&gt;</span>
</code></pre></div>
<p>바이너리에 적혀있는 각각의 번호는 1 바이트의 표현이기 때문에 255까지 있습니다. 바이너리는 255보다 큰 수를 저장하거나 코드 포인트를 UTF8 표현으로 변환하기 위해 수식어를 사용할 수 있습니다.</p>

<p>Each number given to a binary is meant to represent a byte and therefore must go up to 255. Binaries allow modifiers to be given to store numbers bigger than 255 or to convert a code point to its utf8 representation:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="p">&lt;&lt;</span><span class="mi">255</span><span class="p">&gt;&gt;</span>
<span class="go">&lt;&lt;255&gt;&gt;</span>
<span class="gp">iex&gt; </span><span class="p">&lt;&lt;</span><span class="mi">256</span><span class="p">&gt;&gt;</span> <span class="c1"># truncated</span>
<span class="go">&lt;&lt;0&gt;&gt;</span>
<span class="gp">iex&gt; </span><span class="p">&lt;&lt;</span><span class="mi">256</span> <span class="p">::</span> <span class="n">size</span><span class="p">(</span><span class="mi">16</span><span class="p">)&gt;&gt;</span> <span class="c1"># use 16 bits (2 bytes) to store the number</span>
<span class="go">&lt;&lt;1, 0&gt;&gt;</span>
<span class="gp">iex&gt; </span><span class="p">&lt;&lt;</span><span class="mi">256</span> <span class="p">::</span> <span class="n">utf8</span><span class="p">&gt;&gt;</span> <span class="c1"># the number is a code point</span>
<span class="go">&quot;Ā&quot;</span>
<span class="gp">iex&gt; </span><span class="p">&lt;&lt;</span><span class="mi">256</span> <span class="p">::</span> <span class="n">utf8</span><span class="p">,</span> <span class="mi">0</span><span class="p">&gt;&gt;</span>
<span class="go">&lt;&lt;196, 128, 0&gt;&gt;</span>
</code></pre></div>
<p>만약 한 바이트가 8 비트일때, 1 비트만 사용하라는 수식어를 넘기면 어떻게 될까요?</p>

<p>If a byte has 8 bits, what happens if we pass a size of 1 bit?</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="p">&lt;&lt;</span><span class="mi">1</span> <span class="p">::</span> <span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)&gt;&gt;</span>
<span class="go">&lt;&lt;1::size(1)&gt;&gt;</span>
<span class="gp">iex&gt; </span><span class="p">&lt;&lt;</span><span class="mi">2</span> <span class="p">::</span> <span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)&gt;&gt;</span> <span class="c1"># truncated</span>
<span class="go">&lt;&lt;0::size(1)&gt;&gt;</span>
<span class="gp">iex&gt; </span><span class="n">is_binary</span><span class="p">(&lt;&lt;</span> <span class="mi">1</span> <span class="p">::</span> <span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)&gt;&gt;)</span>
<span class="go">false</span>
<span class="gp">iex&gt; </span><span class="n">is_bitstring</span><span class="p">(&lt;&lt;</span> <span class="mi">1</span> <span class="p">::</span> <span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)&gt;&gt;)</span>
<span class="go">true</span>
<span class="gp">iex&gt; </span><span class="n">bit_size</span><span class="p">(&lt;&lt;</span> <span class="mi">1</span> <span class="p">::</span> <span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)&gt;&gt;)</span>
<span class="go">1</span>
</code></pre></div>
<p>더 이상 바이너리 값이 아니고 비트스트링 값입니다 -- 단순한 비트들의의 모임! 즉 바이너리는 8개의 비트스트링으로 구성됩니다.</p>

<p>The value is no longer a binary, but a bitstring -- just a bunch of bits! So a binary is a bitstring where the number of bits is divisible by 8!</p>

<p>바이너리와 비트스트링에도 패턴매칭이 됩니다.</p>

<p>We can also pattern match on binaries / bitstrings:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="p">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">&gt;&gt;</span> <span class="p">=</span> <span class="p">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">&gt;&gt;</span>
<span class="go">&lt;&lt;0, 1, 2&gt;&gt;</span>
<span class="gp">iex&gt; </span><span class="n">x</span>
<span class="go">2</span>
<span class="gp">iex&gt; </span><span class="p">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">&gt;&gt;</span> <span class="p">=</span> <span class="p">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">&gt;&gt;</span>
<span class="gr">** (MatchError) no match of right hand side value: &lt;&lt;0, 1, 2, 3&gt;&gt;</span>
</code></pre></div>
<p>바이너리안에 있는 각각의 값들은 정확히 8비트에 일치해야 하지만 binary 수식어를 통해 나머지 값들을 매칭 시킬수 있습니다.</p>

<p>Note each entry in the binary is expected to match exactly 8 bits. However, we can match on the rest of the binary modifier:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="p">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="p">::</span> <span class="n">binary</span><span class="p">&gt;&gt;</span> <span class="p">=</span> <span class="p">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">&gt;&gt;</span>
<span class="go">&lt;&lt;0, 1, 2, 3&gt;&gt;</span>
<span class="gp">iex&gt; </span><span class="n">x</span>
<span class="go">&lt;&lt;2, 3&gt;&gt;</span>
</code></pre></div>
<p>위 패턴은 바이너리가 <code>&lt;&lt;&gt;&gt;</code> 의 끝에 있어야 동작합니다. 문자열 결합 연산자 <code>&lt;&gt;</code> 로도 유사한 결과를 얻을 수 있습니다.</p>

<p>The pattern above only works if the binary is at the end of <code>&lt;&lt;&gt;&gt;</code>. Similar results can be achieved with the string concatenation operator <code>&lt;&gt;</code>:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="s2">&quot;he&quot;</span> <span class="o">&lt;&gt;</span> <span class="n">rest</span> <span class="p">=</span> <span class="s2">&quot;hello&quot;</span>
<span class="go">&quot;hello&quot;</span>
<span class="gp">iex&gt; </span><span class="n">rest</span>
<span class="go">&quot;llo&quot;</span>
</code></pre></div>
<p>비트스트링, 바이너리와 문자열 여행도 이제 끝입니다. 문자열은 UTF-8로 인코딩된 바이너리이며 바이너리는 8개의 비트수를 가집니다. 여기에서는 비트와 바이트를 유연하게 처리 할 수있는 기능을 Elixir가 제공하는걸 봤지만 실제로는 바이너리를 다룰때 99%의 시간은 <code>is_binary/1</code> 과 <code>byte_size/1</code> 함수를 사용하게 될 것입니다.</p>

<p>This finishes our tour of bitstrings, binaries and strings. A string is a UTF-8 encoded binary, and a binary is a bitstring where the number of bits is divisible by 8. Although this shows the flexibility Elixir provides to work with bits and bytes, 99% of the time you will be working with binaries and using the <code>is_binary/1</code> and <code>byte_size/1</code> functions.</p>

<h2 id="6-3-문자-리스트-char-lists">6.3 문자 리스트 - Char lists</h2>

<p>문자 리스트는 말 그대로 문자의 리스트이지 그 이상 그 이하도 아닙니다:</p>

<p>A char list is nothing more than a list of characters:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="s1">&#39;hełło&#39;</span>
<span class="go">[104, 101, 322, 322, 111]</span>
<span class="gp">iex&gt; </span><span class="n">is_list</span> <span class="s1">&#39;hełło&#39;</span>
<span class="go">true</span>
<span class="gp">iex&gt; </span><span class="s1">&#39;hello&#39;</span>
<span class="go">&#39;hello&#39;</span>
</code></pre></div>
<p>보시다시피 작은따옴표로 둘러싸인 문자리스트는 바이트 값 대신에 각 문자의 코드포인트 값을 포함합니다 (iex에서는 ASCII 범위보다 밖에있는 문자를 포함하면 코드 포인트의 값으로 표시된다는점에 주의하십시요). 큰따옴표로 묶인것은 문자열 (즉 바이너리)인 반면에 작은따옴표로 묶인 것은 문자의 리스트 입니다.</p>

<p>You can see that, instead of containing bytes, a char list contains the code points of the characters between single-quotes (note that iex will only output code points if any of the chars is outside the ASCII range). So while double-quotes represent a string (i.e. a binary), single-quotes represents a char list (i.e. a list).</p>

<p>실제로 문자리스트는 Erlang과의 인터페이싱할때 대부분 사용됩니다. 특히, 바이너리를 인자로 허용하지 않는 오래된 라이브러리에 사용되고 있습니다. <code>to_string/1</code> 와 <code>to_char_list/1</code> 함수를 사용하면 문자리스트를 문자열로 변환하거나 그 반대로 할 수 있습니다:</p>

<p>In practice, char lists are used mostly when interfacing with Erlang, in particular old libraries that do not accept binaries as arguments. You can convert a char list to a string and back by using the <code>to_string/1</code> and <code>to_char_list/1</code> functions:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="n">to_char_list</span> <span class="s2">&quot;hełło&quot;</span>
<span class="go">[104, 101, 322, 322, 111]</span>
<span class="gp">iex&gt; </span><span class="n">to_string</span> <span class="s1">&#39;hełło&#39;</span>
<span class="go">&quot;hełło&quot;</span>
<span class="gp">iex&gt; </span><span class="n">to_string</span> <span class="ss">:hello</span>
<span class="go">&quot;hello&quot;</span>
<span class="gp">iex&gt; </span><span class="n">to_string</span> <span class="mi">1</span>
<span class="go">&quot;1&quot;</span>
</code></pre></div>
<p>위 함수들은 다형성 함수입니다. 문자리스트를 문자열로 변환할 뿐만 아니라 정수에서 문자열, 원자형에서 문자열등의 변환에 사용할 수 있습니다.</p>

<p>Note that those functions are polymorphic. They not only convert char lists to strings, but also integers to strings, atoms to strings, and so on.</p>

<p>바이너리, 문자열, 그리고 문자리스트는 여기까지입니다. 이제 키-값 데이터 구조에 대해 살펴봅시다.</p>

<p>With binaries, strings, and char lists out of the way, it is time to talk about key-value data structures.</p>

  </article><!-- .hfeed -->

  
  <div class="pagination loop-pagination">
    
      <a href="5.html" class="previous page-numbers spec">&larr; Previous</a>
    
      <a class="page-numbers spec" href="#container">Top</a>
    
      <a href="7.html" class="next page-numbers spec">Next &rarr;</a>
    
  </div>
  
</div><!-- #content -->

      </div><!-- #main -->

      <div class="clear">
      </div>

      <div id="copyright">
        © 2012-2014 <a href="http://plataformatec.com.br/">Plataformatec</a>. All rights reserved.
      </p>
    </div><!-- .wrap -->
  </div><!-- #container -->

  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-8268430-6']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script src="/js/toc/toc.js" type="text/javascript" charset="utf-8"></script>
  <script type="text/javascript">
    $(document).ready(function() {
        $('.toc').toc({
          title: '',
          listType: 'ul',
          showSpeed: 0,
        });
    });
  </script>
</body>
</html>

